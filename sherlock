#!/usr/bin/env python

# Copyright (C) k736, inc. All Rights Reserved.
# Unauthorized copying or redistribution of this file is strictly prohibited.

"""
Sherlock

- Subscribe to the directory
- Track routes that target HTTP
- Keep an HAProxy config file updated with tracked routes
"""

from argparse import ArgumentParser
from ConfigParser import SafeConfigParser as ConfigParser
from urlparse import urlparse
from time import time, ctime
from subprocess import Popen

from proton.reactor import Reactor
from datawire import Processor, Receiver

confBase = """
global
    daemon
    maxconn 256

defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend http-in
    bind *:8000""".split("\n")


class Sherlock(object):

    def __init__(self, args):
        self.receiver = Receiver(args.directory, Processor(self))
        self.routeMap = {}  # address -> [ url, url, ... ], policy

        self.updated = True
        self.lastChangeTime = 0
        self.debounceInterval = 2  # seconds
        self.lastConfig = None

    def on_reactor_init(self, event):
        self.receiver.start(event.reactor)

    def on_message(self, event):
        if event.message.subject != "routes":
            return
        msg = event.message
        address = msg.body[0]
        routes = msg.body[1]
        policy = msg.properties["policy"]
        self.routeMap[address] = [target
                                  for (host, port, target), owner in routes
                                  if target and target.upper().startswith("HTTP")], \
                                 policy
        #print address, self.routeMap[address]
        self.updated = True
        self.lastChangeTime = time()
        event.reactor.schedule(self.debounceInterval, self)

    def on_timer_task(self, event):
        if not self.updated:
            return

        now = time()
        if now - self.lastChangeTime < self.debounceInterval:
            event.reactor.schedule(self.debounceInterval, self)
            return

        self.updated = False
        self.pokeHAProxy()

    def render(self):
        head = []
        frontends = []
        backends = []
        for address, (routes, policy) in sorted(self.routeMap.items()):
            head.append("# %s -> (%s) %s" % (address, policy, "; ".join(sorted(routes))))
            urlObj = urlparse(address)
            backend = "BE" + urlObj.path.replace("/", "_")
            pred = "IS" + urlObj.path.replace("/", "_")
            frontends.append("\n    acl %s path_beg %s" % (pred, urlObj.path))
            frontends.append("    use_backend %s if %s" % (backend, pred))
            backends.append("\nbackend %s" % backend)
            for url in sorted(routes):
                urlObj = urlparse(url)
                host = urlObj.hostname
                port = urlObj.port or 80
                name = "%s_%s" % (host, port)
                backends.append("    server %s %s:%s maxconn 32" % (name, host, port))
        return "\n".join(head + confBase + frontends + backends)

    def pokeHAProxy(self):
        cfgData = self.render()
        if cfgData != self.lastConfig:
            self.lastConfig = cfgData
            filename = "ha-%s.conf" % hex(int(time()))
            with open(filename, "wb") as outf:
                outf.write("# Last update %s\n" % ctime())
                outf.write(cfgData)
                outf.write("\n")
            print "Wrote new configuration file to", filename, "at", ctime()
            try:
                command = "haproxy -f %s -p haproxy.pid -sf %s" % (filename, open("haproxy.pid").read())
            except IOError:
                command = "haproxy -f %s -p haproxy.pid" % filename
            try:
                Popen(command.split())
                print "Launched %s" % command
            except OSError as exc:
                print "Failed to launch %r" % command
                print " (%s)" % exc
        else:
            print "Duplicate output suppressed at", ctime()


def main():
    parser = ArgumentParser(add_help=False)
    parser.add_argument("-c", "--config", help="read from config file (no other args)", metavar="FILE")
    args, remaining_argv = parser.parse_known_args()

    if args.config:
        if remaining_argv:
            parser.error("config file, if included, must be the only argument")
            return  # Unreachable
        config = ConfigParser()
        config.read(args.config)
        args.directory = config.get("Sherlock", "directory")
    else:
        parser = ArgumentParser(parents=[parser])
        parser.add_argument("-d", "--directory", default="//localhost/directory")
        args = parser.parse_args()

    Reactor(Sherlock(args)).run()


if __name__ == "__main__":
    main()
