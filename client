#!/usr/bin/env python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import sys
from common import *

try:
    import dbus
    bus = dbus.SessionBus()
    notifications = dbus.Interface(bus.get_object("org.freedesktop.Notifications",
                                                  "/org/freedesktop/Notifications"),
                                   "org.freedesktop.Notifications")
except ImportError:
    notifications = None

class Client(Handler):

    def __init__(self):
        self.messages = []
        self.sent = 0
        self.settled = 0
        self.received = 0
        self.incoming = None
        self.outgoing = None
        self.scratch = Message()
        self.decoder = MessageDecoder()
        self.decoder.on_message = self.on_message
        self.handlers = [FlowController(1024), self.decoder, self]

    def notify(self, msg):
        if notifications is None:
            return
        else:
            app_name     = "Client"
            replace_id   = 1
            icon         = ""
            title        = msg
            text         = ""
            actions_list = ''
            hint         = ''
            time         = 5000   # Use seconds x 1000
            notifications.Notify(app_name, replace_id, icon, title, text, actions_list, hint, time)

    def on_start(self, drv):
        pool.incoming(recv_address)
        pool.outgoing(send_address)

    def on_link_remote_open(self, event):
        link = event.context
        if link.is_sender:
            self.outgoing = link
        else:
            self.incoming = link

    def on_link_final(self, event):
        link = event.context
        if link.is_sender:
            self.outgoing = None
        else:
            self.incoming = None

    def on_link_flow(self, event):
        self.send(event.context)

    def send(self, link):
        while self.messages and link.credit > 0:
            dlv = link.delivery("spout-%s" % self.sent)
            self.scratch.clear()
            self.scratch.body = self.messages.pop()
            link.send(self.scratch.encode())
            link.advance()
            self.sent += 1

    def on_quiesced(self, drv):
        if self.outgoing != None:
            self.send(self.outgoing)

    def on_delivery(self, event):
        dlv = event.context
        if dlv.link.is_sender:
            if dlv.settled:
                self.settled += 1
                dlv.settle()

    def on_message(self, rcv, message):
        sys.stdout.write("\r<-- %s\n--> " % message.body)
        sys.stdout.flush()
        from_addr = rcv.target.address or rcv.source.address
        self.notify("(%s) %s" % (from_addr, message.body))
        self.received += 1

    def on_connection_remote_close(self, event):
        print "\rSent %s, settled %s, received %s" % (self.sent, self.settled, self.received)
        drv.exit()

    def on_transport_closed(self, event):
        drv.schedule(self.reconnect, 1)

    def reconnect(self):
        print "reconnecting"
        pool.incoming(recv_address)
        pool.outgoing(send_address)

switches = [a for a in sys.argv[1:] if a.startswith("-")]
args = [a for a in sys.argv[1:] if not a.startswith("-")]

recv_address = args.pop(0) if args and args[0].startswith("/") else "//localhost"
send_address = args.pop(0) if args and args[0].startswith("/") else recv_address

coll = Collector()
pool = Pool(coll)

client = Client()

drv = Driver(coll, pool, client)
drv.start()

try:
    while True:
        line = raw_input("--> ")
        client.messages.append(unicode(line))
        drv.wakeup()
except EOFError:
    pass

if client.outgoing: client.outgoing.session.connection.close()
if client.incoming: client.incoming.session.connection.close()
drv.exit()
drv.wakeup()
drv.join()
