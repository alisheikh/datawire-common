Barker
######

Barker is a set of microservices that mimics sending a tweet ("bark")
to a set of followers. Barker is intended to illustrate how to design
and connect a set of microservices using Datawire.

Barker Quickstart
=================

Barker includes a launch script that will start all the Barker
microservices::

  cd barker
  python launch.py

Visit barker/webui/index.html in your browser to see the Barker
UI. You'll see a set of barks continuously scroll by; these are
automatically generated by the ``autobark.py`` client. You can also
type a bark into the UI, and you'll see it appear in set of barks.

Barker also includes a basic monitoring setup. You can start the
monitoring with the monitoring launch script::

  cd monitoring
  python launch.py

Visit monitoring/index.html in your browser, and you'll see two
real time graphs giving visibility into the state of the system.

Architecture
============

The architectural design of Barker is influenced by this `article
about Twitter scalability
<http://highscalability.com/blog/2013/7/8/the-architecture-twitter-uses-to-deal-with-150m-active-users.html>`_. This
design is also very generalizable to other types of processing
problems, and resembles the `LMAX architecture
<http://martinfowler.com/articles/lmax.html>`_.

.. image:: barker-arch.png
   :width: 100%

ARK3, please put poignant and insightful commentary here.
	   
Barker Slow Start
=================

Now that you have a grasp of the Barker archtiecture, let's go through
Barker in more detail. The launch script starts a number of different
microservices locally, each operating a different host port. The main
services are the following:

* directory, which provides service location functionality
* a manifold that functions as the "inbox"
* an instance of business logic
* three manifold instances that function as the "outbox"
* five autobark instances that simulate multiple tweeters

We've instantiated different numbers of microservices to demonstrate
several different routing algorithms.

In the outbox, we use a round robin algorithm that distributes
connections between different instances of the outbox. In the
bizlogic, we use a failover algorithm.

To demonstrate the failover algorithm, copy the ``launch.py`` script
to ``launch-no-bizlogic.py`` and comment out the bizlogic command.
Then, run the following commands::

  python launch-no-bizlogic.py &
  python bizlogic.py --host 127.0.0.1 --port 5680 &
  python bizlogic.py --host 127.0.0.1 --port 5681 &

Substitute a different hostname for 127.0.0.1 if you are not running
on localhost. Then, start the monitoring::

  cd monitoring
  python launch.py

Load the monitoring UI in your browser. Barks will be routed through
the bizlogic on 5680. If you kill the first bizlogic process, barks
will be routed to the second bizlogic on 5681. You'll see a small,
temporary increase in queue depth when you kill the first bizlogic
process as the failover occurs. If you kill the second bizlogic,
you'll see the queue depth will increase indefinitely. Starting a new
instance of the bizlogic will start queue processing again.
  

UI and Monitoring
=================

Barker relies on the ``proton.js`` library to stream data directly
into your browser, over AMQP on WebSockets. This is used in both the
Barker UI, as well as the monitoring dashboards.

The ``proton.js`` library should be considered experimental, as the
Python reactive API is not yet implemented in ``proton.js``.
