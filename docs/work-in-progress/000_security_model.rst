.. Datawire.io documentation master file, created by
   sphinx-quickstart on Tue Jan 27 12:04:31 2015.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

Datawire Security Architecture
******************************


https://blog.cloudflare.com/how-to-build-your-own-public-key-infrastructure/

The Datawire security architecture is a "zero trust" security model
where security is ubiquitous throughout the infrastructure. In this
model, there is no perimeter, and authentication and trust are
established on a per message basis (with additional features to
improve throughput).

To protect against errant subscribers, all messages are fully
encrypted.


Authentication
==============

The authentication model for Datawire services is a Trust On First Use
(TOFU) model that is conceptually similar to ssh. The authentication
workflow is described below.

Definitions
-----------

Address
 - A destination for messages
 - Each address has a 1..1 relationship with a public key.

Security session
 - Governed by a randomly generated symmetric key.


Auth Handshake
--------------

When entity A wants to send a message to entity B, the following
handshake authenticates the public key associated with A's address:

#. A sends to B a signed message containing::

   - A's public key
   - Public key algorithm name
   - Reply-to address
   - Organization name
   - Sender name

#. B verifies the signature on the message.

#. B checks its local key database.

   * If A's public key/reply-to address match a pre-existing entry,
     B does nothing further.
   * If A's public key is not in the database, or it does not match an
     existing entry, B sends a control message to its administrator(s)
     asking for further instructions.

#. The reverse of this process is also performed, with B sending an
   authentication message to A. Both parts of this process can be done
   asynchronously.

Security Sessions
-----------------

To reduce the overhead of public key operations, symmetric keys are
used when possible. When entity A wants to send a message to entity B,
the authentication handshake is first performed to validate/exchange
public keys.

#. A generates two random 256-bit symmetric keys, one for encryption,
   and one for signing.

#. Using B's public key, A encrypts the symmetric key and sends the
   result to B.

#. When A wants to send a message to B, it first compresses the body
   payload, and then encrypts the payload with the encryption key.

#. A signs the message with the signing key. The digital signature
   includes a nonce to detect replay scenarios.

Intermediaries and Key Copying
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Authentication handshakes between two endpoints when an intermediary
is involved requires some additional intelligence in the
intermediary. In the following scenario, A is the publisher, while B
and B' are subscribers. A is publishing to T, a topic.

#. A authenticates to T, using the authentication handshake described
   above.

#. A creates a security session key, and encrypts the session key
   using T's pubic key.

#. T performs an authentication handshake with B and B'.

#. T decrypts the security session key using T's private key, and
   re-encrypts the security session key using the public keys of B and
   B'.

#. T sends the security session key to B and B'.

#. All subsequent messages from A to B and B' can be proxied by T
   without any encryption/decryption operation.

If a new subscriber B'' is added, T shares the security session key
with B'' after an authentication handshake.

If B' no longer is a subscriber, T can request a new security session
key from A.

Revocation
^^^^^^^^^^

Session keys are always generated by the source (sender). As such, the
sender can set arbitrary policy on when to revoke session keys.

In addition, targets can request (but not require) the sender to
revoke a session key by sending a revocation request to the sender.


Wire Level Protection
---------------------

All traffic is encrypted using TLS, with Elliptic Curve Diffie Hellman
(ECDHE) used for key exchange. This has several benefits:

- perfect forward secrecy
- no need to manage SSL certificates
- protect against message header analysis

Links
-----

* https://rietta.com/blog/2012/01/27/openssl-generating-rsa-key-from-command/.
* http://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
* http://docs.aws.amazon.com/general/latest/gr/sigv4-signed-request-examples.html
* https://www.duosecurity.com/docs/authapi#authentication
* https://www.usenix.org/conference/lisa13/enterprise-architecture-beyond-perimeter
