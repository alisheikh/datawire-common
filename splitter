#!/usr/bin/env python

from common import *
from service import *

class Entry:

    def __init__(self, message):
        self.message = message
        self.consumed = False

class SingleStore:

## I want to be able to figure out the bottleneck queue, and delete extra messages accordingly

    def __init__(self):
        self.serial = 0
        self.entries = []

    def add(self, msg):
        self.entries.append(Entry(msg))

    def max(self):
        return self.serial + len(self.entries)

    def min(self):
        return self.serial

    def get(self, serial):
        return self.entries[serial - self.serial]

    def gc(self, serial):
        ## Old data will no longer be accessed, delete old data and recalculate serial
        if self.serial < serial:
            delta = serial - self.serial
            del self.entries[:delta]
            self.serial += delta


class ScopedStore:

    def __init__(self):
        self.single_stores = {}

    def _get_single_store(self, address):
        if address not in self.single_stores:
            self.single_stores[address] = SingleStore()
        return self.single_stores[address]

    def add(self, address, msg):
        return self._get_single_store(address).add(msg)

    def max(self, address):
        return self._get_single_store(address).max()

    def min(self, address):
        return self._get_single_store(address).min()

    def get(self, address, serial):
        return self._get_single_store(address).get(serial)

    def gc(self, address, serial):
        return self._get_single_store(address).gc(serial)


class Splitter(Service):

    def __init__(self, local_host="localhost", local_port=5672, pubhost=None, pubport=None, redirector=None, id=None, trace=False):
        pubhost = pubhost or local_host
        pubport = pubport or local_port
        redirector = redirector if redirector and id else "localhost"
        self.trace = trace
        id = id or ""

        Service.__init__(self, redirector, id, local_host, local_port, trace, pubhost=pubhost, pubport=pubport)

        self.store = ScopedStore()
        self.consumers = []
        self.subscribers = []
        self.handlers = [Handshaker(), FlowController(1024), self]

    # def on_start(self, drv):
    #    drv.acceptor("localhost", 5672)

    def is_consumer(self, snd):
        return snd.source.address and snd.source.address.endswith("?consumer")

    def on_link_remote_open(self, event):
        if event.link.is_sender:
            address = event.link.target.address
            event.link.serial = self.store.max(address)
            if self.is_consumer(event.link):
                self.consumers.append(event.link)
            else:
                self.subscribers.append(event.link)
        else:
            address = event.link.source.address

    def on_link_flow(self, event):
        if event.sender:
            self.pump(event.sender)

    def pump(self, snd):
        address = snd.target.address
        while snd.serial < self.store.max(address) and snd.credit > 0 and snd.queued < 1024:
            entry = self.store.get(address, snd.serial)
            consumer = self.is_consumer(snd)
            if (not entry.consumed or not consumer):
                dlv = snd.delivery("")
                snd.send(entry.message)
                dlv.settle()
                if consumer:
                    entry.consumed = True
            snd.serial += 1

    def on_delivery(self, event):
        dlv = event.delivery
        link = event.link
        if link.is_receiver and not dlv.partial:
            self.store.add(link.source.address, link.recv(dlv.pending))

            ## Find out minimal serial of the subscribers and garbage collect
            minSerial = self.store.max(link.source.address)

            for snd in self.subscribers:
                self.pump(snd)
                minSerial = min(minSerial, snd.serial)
            for snd in self.consumers:
                self.pump(snd)
                minSerial = min(minSerial, snd.serial)

            if self.consumers:
                self.consumers.append(self.consumers.pop(0))

            self.store.gc(link.source.address, minSerial)

            dlv.settle()

parser = argparse.ArgumentParser(parents=[get_base_argparser()])
parser.add_argument('-i', '--id', default=None,
                    help='id of splitter as accessed via redirector')
args = parser.parse_args()

trace = args.trace
host = args.host
pubhost = args.public_host
port = args.port
pubport = args.public_port
redirector = args.redirector
id = args.id

drv = Driver(Splitter(id=id, redirector=redirector, local_host=host, local_port=port, pubhost=pubhost, pubport=pubport, trace=trace))
drv.run()
