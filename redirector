#!/usr/bin/env python
import random, sys, os, argparse
from common import *
from service import get_base_argparser

class Redirector(Handler, Logger):

    def __init__(self, host, port, trace=None, pubhost=None, pubport=None):
        self.host = host
        self.port = port
        self.trace = trace
        self.pubhost = pubhost or host
        self.pubport = pubport or port
        self.address = "//%s:%s" % (self.pubhost, self.pubport)
        if self.pubport == 5672:
            self.address = "//%s" % (pubhost or host)
        self.services = {}
        self.handlers = [Handshaker(), self]
        self.count = 0

    def on_start(self, drv):
        drv.acceptor(self.host, self.port)

    def ancestors(self, address):
        yield address
        if address is None: return
        address = address.split("?", 1)[0]
        path = address.split("/")
        while path:
            addr = "/".join(path)
            yield addr
            path.pop()

    def choose(self, address):
        for addr in self.ancestors(address):
            hosts = self.services.get(addr, None)
            if hosts:
                choice = hosts[self.count % len(hosts)]
                self.count += 1
                return choice
        return None

    def on_connection_init(self, event):
        conn = event.connection
        conn.finalizer = None

    def qualify(self, address):
        if address and address[0] == "/":
            return address
        else:
            return "%s/%s" % (self.address, address)

    def on_connection_remote_open(self, event):
        conn = event.connection
        props = conn.remote_properties
        if props and "service" in props:
            service = props["service"]
            address, host, port = service
            address = self.qualify(address)
            if address not in self.services:
                self.services[address] = []
            self.services[address].append(conn)
            conn.finalizer = self.on_service_final
            self.log("Adding service %s", service)
            self.log("Services: %s", self.services)
        else:
            drv.schedule(conn.close, 10)

    def on_link_remote_open(self, event):
        link = event.link
        if link.is_sender:
            address = link.remote_source.address or link.remote_target.address
        else:
            address = link.remote_target.address or link.remote_source.address

        node = self.choose(address)
        if node:
            _, host, port = node.remote_properties["service"]
            if not link.is_sender or self.qualify("dynamic") not in self.services or uid_pattern.match(link.remote_target.address) is None:
                self.log("Redirecting to %s:%s", host, port)
                link.condition = Condition("amqp:link:redirect", None,
                                           {symbol("network-host"): host,
                                            symbol("port"): port})
            else:
                dyn_node = self.choose(self.qualify("dynamic"))
                _, dyn_host, dyn_port = dyn_node.remote_properties["service"]
                self.log("Redirecting to dynamic splitter at %s:%s", dyn_host, dyn_port)
                link.condition = Condition("amqp:link:redirect", None,
                                           {symbol("network-host"): dyn_host,
                                            symbol("port"): dyn_port})
        else:
            self.log("No service for %s", address)
            link.condition = Condition("amqp:link:detach-forced", "no service")
        link.close()

    def on_service_final(self, conn):
        service = conn.remote_properties["service"]
        address, host, port = service
        address = self.qualify(address)
        self.log("Removing service %s", service)
        self.services.get(address, []).remove(conn)
        self.log("Services: %s", self.services)

    def on_transport_closed(self, event):
        conn = event.connection
        if conn.finalizer:
            conn.finalizer(conn)
        conn.free()
        event.transport.unbind()

parser = argparse.ArgumentParser(parents=[get_base_argparser()])
args = parser.parse_args()

trace = args.trace
host = args.host
port = int(args.port)
pubhost = args.public_host if args.public_host else host
pubport = int(args.public_port) if args.public_port else port

drv = Driver(Redirector(host, port, trace, pubhost=pubhost, pubport=pubport))
drv.run()
