#!/usr/bin/env python
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import argparse, os, sys, time, psutil
from common import *

class Client(Handler):

    def __init__(self, address, count, rate, batch):
        self.address = Address(address)
        self.sent = 0
        self.throttled = 0
        self.scratch = Message()
        self.count = count
        self.rate = rate
        self.batch = batch
        self.connections = {}

    def on_start(self, drv):
        self.driver = drv
        self.sample()
        self.generate()
        self.check_connections()
        self.driver.schedule(self.report, 1)

    def check_connections(self):
        count = len(self.connections)
        if count < self.count:
            for i in range(min(100, self.count - count)):
                conn, snd = self.connect(self.address)
                self.connections[conn] = snd
        self.driver.schedule(self.check_connections, 1)

    def connect(self, address):
        conn = self.driver.connection()
        conn.hostname = address.host
        ssn = conn.session()
        snd = ssn.sender(str(address))
        snd.target.address = str(address)
        snd.open()
        ssn.open()
        conn.open()
        return conn, snd

    def on_connection_remote_close(self, event):
        conn = event.connection
        if conn.remote_condition and conn.remote_condition.name == "amqp:connection:redirect":
            info = conn.remote_condition.info
            host = info["network-host"]
            port = info["port"]
            address = Address("//%s:%s" % (host, port))
            conn.close()
            print "redirecting to %s" % address
            rconn, snd = self.connect(address)
            self.connections[rconn] = snd

    def on_transport_closed(self, event):
        event.connection.free()
        event.transport.unbind()

    def on_connection_final(self, event):
        del self.connections[event.connection]

    def on_transport_error(self, event):
        print event.context.condition

    def on_link_init(self, event):
        link = event.context
        if link.is_sender:
            link.last_msg = None
            link.flowed = False

    def on_link_flow(self, event):
        link = event.context
        if link.is_sender:
            link.flowed = True
            self.send(link)

    def on_link_final(self, event):
        link = event.context
        if link.is_sender:
            del link.last_msg

    def send(self, link):
        if not hasattr(link, "last_msg"): return
        if link.last_msg and (self.driver.now - link.last_msg < 1.0/self.rate):
            return
        remaining = self.batch
        while remaining and link.credit:
            dlv = link.delivery("generate-%s" % self.sent)
            self.scratch.clear()
            self.scratch.body = [self.cpu]
            link.send(self.scratch.encode())
            dlv.settle()
            #print "Sent:", self.scratch
            self.sent += 1
            remaining -= 1

        if remaining > 0:
            if link.flowed:
                self.throttled += remaining
        else:
            link.last_msg = self.driver.now

    def generate(self):
        for snd in self.connections.values():
            self.send(snd)
        self.driver.schedule(self.generate, 1.0/self.rate)

    def sample(self):
        self.cpu = (u"cpu", time.time(), psutil.cpu_percent(None))
        self.driver.schedule(self.sample, 0.25)

    def report(self):
        print "Connections:", len(self.connections), "Sent:", self.sent, \
            "Throttled: ", self.throttled
        self.driver.schedule(self.report, 1)

parser = argparse.ArgumentParser(description="metric generator")
parser.add_argument('-c', '--count', type=int, default=1, help="connection count")
parser.add_argument('-r', '--rate', type=float, default=4, help="metric rate")
parser.add_argument('-b', '--batch', type=int, default=1, help="batch size")
parser.add_argument('address', nargs='?', default='//localhost', help='target address')

args = parser.parse_args()

drv = Driver(Client(args.address, args.count, args.rate, args.batch))
drv.run()
